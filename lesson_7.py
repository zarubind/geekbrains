# 1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()), который должен
# принимать данные (список списков) для формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
# Примеры матриц вы найдете в методичке.
# Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
# Далее реализовать перегрузку метода __add__() для реализации операции сложения двух объектов класса Matrix (двух
# матриц). Результатом сложения должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки первой матрицы складываем с
# первым элементом первой строки второй матрицы и т.д.

class Matrix:
    def __init__(self, matrix):
        self.matrix = matrix

    def __str__(self):
        ret = ''
        for i in self.matrix:
            for j in i:
                ret = ret + str(j) + '\t'
            ret = ret + '\n'
        return ret

    def __add__(self, other):
        new_matrix = []
        for i in range(max(len(self.matrix), len(other.matrix))):
            tmp = []
            for j in range(max(len(self.matrix[i]), len(other.matrix[i]))):
                try:
                    a = self.matrix[i][j]
                except IndexError:
                    a = 0
                try:
                    b = other.matrix[i][j]
                except IndexError:
                    b = 0
                tmp.append(a + b)
            new_matrix.append(tmp)
        return Matrix(new_matrix)

my_matrix1 = Matrix([[31, 22], [37, 43], [51, 86]])
my_matrix2 = Matrix([[3, 5, 32], [2, 4, 6], [-1, 64, -8]])
my_matrix3 = Matrix([[3, 5, 8, 3], [8, 3, 7, 1]])

print(my_matrix1)
print(my_matrix2)

print(my_matrix1 + my_matrix2)

# 2. Реализовать проект расчета суммарного расхода ткани на производство одежды. Основная сущность (класс) этого проекта
# — одежда, которая может иметь определенное название. К типам одежды в этом проекте относятся пальто и костюм. У этих
# типов одежды существуют параметры: размер (для пальто) и рост (для костюма). Это могут быть обычные числа: V и H,
# соответственно. Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5),
# для костюма (2 * H + 0.3). Проверить работу этих методов на реальных данных. Реализовать общий подсчет расхода ткани.
# Проверить на практике полученные на этом уроке знания: реализовать абстрактные классы для основных классов проекта,
# проверить на практике работу декоратора @property.

class Wear:
    def __init__(self, param):
        self.param = param
        self.name = ''
        self.type = ''

    def __str__(self):
        return f'{self.name} ({self.type}={self.param})'

    @property
    def l_cloth(self):
        if self.type == 'V':
            return self.param / 6.5 + 0.5
        elif self.type == 'H':
            return self.param * 2 + 0.3
        else:
            return None

class Coat(Wear): # пальто
    def __init__(self, param):
        super().__init__(param)
        self.name = 'Coat'
        self.type = 'V'

class Costume(Wear): # костюм
    def __init__(self, param):
        super().__init__(param)
        self.name = 'Costume'
        self.type = 'H'

wear = [Coat(50), Coat(52), Costume(180), Costume(185)]
sum = 0
for i in wear:
    sum += i.l_cloth
    print(i)
print(sum)

# 3. Реализовать программу работы с органическими клетками. Необходимо создать класс Клетка. В его конструкторе
# инициализировать параметр, соответствующий количеству клеток (целое число). В классе должны быть реализованы методы
# перегрузки арифметических операторов: сложение (__add__()), вычитание (__sub__()), умножение (__mul__()), деление
# (__truediv__()).Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение, умножение и
# обычное (не целочисленное) деление клеток, соответственно. В методе деления должно осуществляться округление значения
# до целого числа.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух
# клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток
# больше нуля, иначе выводить соответствующее сообщение.
# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек
# этих двух клеток.
# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества
# ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду. Данный
# метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5.
# Тогда метод make_order() вернет строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5.
# Тогда метод make_order() вернет строку: *****\n*****\n*****.
# Подсказка: подробный список операторов для перегрузки доступен по ссылке
# (https://pythonworld.ru/osnovy/peregruzka-operatorov.html).

class Cell:
    def __init__(self, count):
        self.count = count

    def __add__(self, other):
        return Cell(self.count + other.count)

    def __sub__(self, other):
        if self.count - other.count > 0:
            return Cell(self.count - other.count)
        else:
            print('Error')
            return None

    def __mul__(self, other):
        return Cell(self.count * other.count)

    def __truediv__(self, other):
        return Cell(self.count // other.count)

    def make_order(self, len):
        ret = ''
        for i in range(self.count // len):
            ret += '*' * len + '\n'
        ret += '*' * (self.count % len)
        print(ret)

a = Cell(12)
b = Cell(5)
c = a + b
c.make_order(5)
